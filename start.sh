#!/usr/bin/env bash

# Возьмем имя из аргументов сркипта,
# запустив `start.sh Victor`, $0 - это `start.sh`, $1 - первый аргумент и т.д.
NAME=$1

# `if` это конструкиця для выполнения кода по условию
if [[ ${NAME} == "" ]] ; then
  echo "Missing argument"

  # Так выходится из скрипты (остановка его выполнене на этой строчке)
  # Можно посто выйти вот так
  # exit
  # Но обычно вызвращают код возврата: 0 - обычно успех, больше нуля это ошибки какие-то.
  exit 1
fi

# Объявим функцию обычно для повторонго использования,
# или просто что сгруппировать код в мелкие куски и потом вызывать для читаемости.
# Для удобной читаемости, название функций должны представлять что она делает (как в приницпе и с названиями переменных)
say_hello () {
  # $1 в данном случае уже первый аргумент но не срикпта, а функции.
  STR="Hello, $1!"

  echo ${STR}

  # Функция может возвращать статус своего выполнения.
  # Статус это целое числоб на подобие как сркипты выходят из исопльнения при помощи команды `exit`.
  # Обычно 0 - это успех, все остальное нет.
  return 0
}

# Вызываем нашу функцию и передаем ей параметр.
say_hello ${NAME}

# Переменная `$?` содержит результат последней выполненой функции.
echo "The previous function has a return value of $?"

# Другая функция
lines_in_file () {
  # `cat` - это системная функция, точнее говоря это внешний скрипт (программа),
  # которая, наверное, есть везде в линуксах. Она читает и выдает на экран файл.
  # Подробнее `man cat`. Можешь попробовать `cat README.md`
  # `wc` - другая программа считающая количество линий, слов, букв, байт.
  # Подробнее `man wc`. Можешь попробовать `wc -l README.md`, `wc -c README.md`
  # В данном примере выолняются два этих сррипта, передавая результат из `cat`в команду `wc`
  cat $1 | wc -l
}

# `$( )` это запуск кода, функции, внешнего скрипта и возвратить результат,
# в данном примере в переменную
NUM_LINES=$( lines_in_file $0 )

echo The file \"$0\" has ${NUM_LINES} lines in it.
